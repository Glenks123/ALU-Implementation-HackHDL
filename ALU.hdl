/**
 * ALU (Arithmetic Logic Unit):
 * Computes out = one of the following functions:
 *                0, 1, -1,
 *                x, y, !x, !y, -x, -y,
 *                x + 1, y + 1, x - 1, y - 1,
 *                x + y, x - y, y - x,
 *                x & y, x | y
 * on the 16-bit inputs x, y,
 * according to the input bits zx, nx, zy, ny, f, no.
 * In addition, computes the two output bits:
 * if (out == 0) zr = 1, else zr = 0
 * if (out < 0)  ng = 1, else ng = 0
 */
// Implementation: Manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) sets x = 0        // 16-bit constant
// if (nx == 1) sets x = !x       // bitwise not
// if (zy == 1) sets y = 0        // 16-bit constant
// if (ny == 1) sets y = !y       // bitwise not
// if (f == 1)  sets out = x + y  // integer 2's complement addition
// if (f == 0)  sets out = x & y  // bitwise and
// if (no == 1) sets out = !out   // bitwise not

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute (out = x + y) or (out = x & y)?
        no; // negate the out output?
    OUT 
        out[16], // 16-bit output
        zr,      // if (out == 0) equals 1, else 0
        ng;      // if (out < 0)  equals 1, else 0

    PARTS:
    //// Replace this comment with your code.
    // zeroing inputs
    Mux16(a=x, b=false, sel=zx, out=x1);
    Mux16(a=y, b=false, sel=zy, out=y1);
    
    // negating input
    Not16(in=x1, out=x2);
    Mux16(a=x1, b=x2, sel=nx, out=x3);
    Not16(in=y1, out=y2);
    Mux16(a=y1, b=y2, sel=ny, out=y3);

    // anding and addition
    Add16(a=x3, b=y3, out=tOut1);
    And16(a=x3, b=y3, out=tOut2);
    Mux16(a=tOut2, b=tOut1, sel=f, out=tOut3);

    // negating output
    Not16(in=tOut3, out=tOut4);
    Mux16(a=tOut3, b=tOut4, sel=no, out=out, out=outFlag, out[0..7]=outFlag1, out[8..15]=outFlag2, out[15]=outMsb); // the reason we are creating these flags is because we want to access them when implementing the zr control bit. This is because internal input pins cannot be indexed and the output pin cannot be used as an input, so we need to delcare this flag here that we can access later.

    // zr output control bit
    Or8Way(in=outFlag1, out=tOut5);
    Or8Way(in=outFlag2, out=tOut6);
    Or(a=tOut5, b=tOut6, out=tOut7);
    Not(in=tOut7, out=zr);

    // ng output control bit
    Or(a=outMsb, b=false, out=ng);
}